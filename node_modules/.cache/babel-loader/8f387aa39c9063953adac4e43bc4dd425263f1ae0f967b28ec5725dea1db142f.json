{"ast":null,"code":"import _defineProperty from \"/Users/guilherme/Downloads/react-loan-calculator-main/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/guilherme/Downloads/react-loan-calculator-main/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/guilherme/Downloads/react-loan-calculator-main/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../colDef';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport var COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nexport var computeColumnTypes = function computeColumnTypes() {\n  var customColumnTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var mergedColumnTypes = _extends({}, getGridDefaultColumnTypes());\n  Object.entries(customColumnTypes).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      colType = _ref2[0],\n      colTypeDef = _ref2[1];\n    if (mergedColumnTypes[colType]) {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colType], colTypeDef);\n    } else {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    }\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth(_ref3) {\n  var initialFreeSpace = _ref3.initialFreeSpace,\n    totalFlexUnits = _ref3.totalFlexUnits,\n    flexColumns = _ref3.flexColumns;\n  var flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: function freeze(field) {\n      var value = flexColumnsLookup.all[field];\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n    var violationsLookup = {\n      min: {},\n      max: {}\n    };\n    var remainingFreeSpace = initialFreeSpace;\n    var flexUnits = totalFlexUnits;\n    var totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(function (field) {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n    for (var i = 0; i < flexColumns.length; i += 1) {\n      var column = flexColumns[i];\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n      var widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      var computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth: computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(function (field) {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(function (field) {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(function (_ref4) {\n        var field = _ref4.field;\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n    loopOverFlexItems();\n  }\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport var hydrateColumnsWidth = function hydrateColumnsWidth(rawState, viewportInnerWidth) {\n  var columnsLookup = {};\n  var totalFlexUnits = 0;\n  var widthAllocatedBeforeFlex = 0;\n  var flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(function (columnField) {\n    var newColumn = _extends({}, rawState.lookup[columnField]);\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      var computedWidth;\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n    columnsLookup[columnField] = newColumn;\n  });\n  var initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    var computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace: initialFreeSpace,\n      totalFlexUnits: totalFlexUnits,\n      flexColumns: flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(function (field) {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nvar columnTypeWarnedOnce = false;\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport var applyInitialState = function applyInitialState(columnsState, initialState) {\n  if (!initialState) {\n    return columnsState;\n  }\n  var _initialState$ordered = initialState.orderedFields,\n    orderedFields = _initialState$ordered === void 0 ? [] : _initialState$ordered,\n    _initialState$dimensi = initialState.dimensions,\n    dimensions = _initialState$dimensi === void 0 ? {} : _initialState$dimensi;\n  var columnsWithUpdatedDimensions = Object.keys(dimensions);\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n  var orderedFieldsLookup = {};\n  var cleanOrderedFields = [];\n  for (var i = 0; i < orderedFields.length; i += 1) {\n    var field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n  var newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.all : [].concat(cleanOrderedFields, _toConsumableArray(columnsState.all.filter(function (field) {\n    return !orderedFieldsLookup[field];\n  })));\n  var newColumnLookup = _extends({}, columnsState.lookup);\n  var _loop = function _loop() {\n    var field = columnsWithUpdatedDimensions[_i];\n    var newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n    Object.entries(dimensions[field]).forEach(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        key = _ref6[0],\n        value = _ref6[1];\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  };\n  for (var _i = 0; _i < columnsWithUpdatedDimensions.length; _i += 1) {\n    _loop();\n  }\n  var newColumnsState = {\n    all: newOrderedFields,\n    lookup: newColumnLookup\n  };\n  return newColumnsState;\n};\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport var getGridColDef = function getGridColDef(columnTypes, type) {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([\"MUI: The column type \\\"\".concat(type, \"\\\" you are using is not supported.\"), \"Column type \\\"string\\\" is being used instead.\"].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n  return columnTypes[type];\n};\nexport var createColumnsState = function createColumnsState(_ref7) {\n  var apiRef = _ref7.apiRef,\n    columnsToUpsert = _ref7.columnsToUpsert,\n    initialState = _ref7.initialState,\n    columnTypes = _ref7.columnTypes,\n    _ref7$currentColumnVi = _ref7.currentColumnVisibilityModel,\n    currentColumnVisibilityModel = _ref7$currentColumnVi === void 0 ? gridColumnVisibilityModelSelector(apiRef) : _ref7$currentColumnVi,\n    shouldRegenColumnVisibilityModelFromColumns = _ref7.shouldRegenColumnVisibilityModelFromColumns,\n    _ref7$keepOnlyColumns = _ref7.keepOnlyColumnsToUpsert,\n    keepOnlyColumnsToUpsert = _ref7$keepOnlyColumns === void 0 ? false : _ref7$keepOnlyColumns;\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n  var isInsideStateInitializer = !apiRef.current.state.columns;\n  var columnsStateWithoutColumnVisibilityModel;\n  if (isInsideStateInitializer) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    var currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: keepOnlyColumnsToUpsert ? [] : _toConsumableArray(currentState.all),\n      lookup: _extends({}, currentState.lookup) // Will be cleaned later if keepOnlyColumnsToUpsert=true\n    };\n  }\n\n  var columnsToKeep = {};\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).reduce(function (acc, key) {\n      return _extends({}, acc, _defineProperty({}, key, false));\n    }, {});\n  }\n  var columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(function (newColumn) {\n    var field = newColumn.field;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    var existingState = columnsStateWithoutColumnVisibilityModel.lookup[field];\n    if (existingState == null) {\n      // New Column\n      existingState = _extends({}, getGridColDef(columnTypes, newColumn.type), {\n        // TODO v6: Inline `getGridColDef`\n        field: field,\n        hasBeenResized: false\n      });\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    }\n    var hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(function (key) {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsStateWithoutColumnVisibilityModel.lookup[field] = _extends({}, existingState, {\n      hide: newColumn.hide == null ? false : newColumn.hide\n    }, newColumn, {\n      hasBeenResized: hasBeenResized\n    });\n  });\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).forEach(function (field) {\n      if (!columnsToKeep[field]) {\n        delete columnsStateWithoutColumnVisibilityModel.lookup[field];\n      }\n    });\n  }\n  var columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n  var columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  var columnVisibilityModel = {};\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    var hasModelChanged = false;\n    var newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n    if (isInsideStateInitializer) {\n      columnsStateWithPreProcessing.all.forEach(function (field) {\n        newColumnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else if (keepOnlyColumnsToUpsert) {\n      // At this point, `keepOnlyColumnsToUpsert` has a new meaning: keep the columns\n      // passed via `columnToUpsert` + columns added by the pre-processors. We do the following\n      // cleanup because a given column may have been removed from the `columns` prop but it still\n      // exists in the state.\n      Object.keys(newColumnVisibilityModel).forEach(function (field) {\n        if (!columnsStateWithPreProcessing.lookup[field]) {\n          delete newColumnVisibilityModel[field];\n          hasModelChanged = true;\n        }\n      });\n    }\n    columnsStateWithPreProcessing.all.forEach(function (field) {\n      // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n      // Then we don't want to update the visibility status of the column in the model.\n      if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n        return;\n      } // We always assume that a column not in the model is visible by default. However, there's an\n      // edge case where the column is not in the model but it also doesn't exist in the `columns`\n      // prop, meaning that the column is being added. In that case, we assume that the column was\n      // not visible before for it be added to the model.\n\n      var isVisibleBefore = currentColumnVisibilityModel[field];\n      if (isVisibleBefore === undefined) {\n        if (isInsideStateInitializer) {\n          isVisibleBefore = true;\n        } else {\n          var _currentState = gridColumnsSelector(apiRef.current.state);\n          isVisibleBefore = !!_currentState.lookup[field];\n        }\n      }\n      var isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n      if (isVisibleAfter !== isVisibleBefore) {\n        hasModelChanged = true;\n        newColumnVisibilityModel[field] = isVisibleAfter;\n      }\n    });\n    if (hasModelChanged || isInsideStateInitializer) {\n      columnVisibilityModel = newColumnVisibilityModel;\n    } else {\n      columnVisibilityModel = currentColumnVisibilityModel;\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n  var columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  var columnsState = _extends({}, columnsStateWithPortableColumns, {\n    columnVisibilityModel: columnVisibilityModel\n  });\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport var mergeColumnsState = function mergeColumnsState(columnsState) {\n  return function (state) {\n    return _extends({}, state, {\n      columns: columnsState\n    });\n  };\n};\nexport function getFirstNonSpannedColumnToRender(_ref8) {\n  var firstColumnToRender = _ref8.firstColumnToRender,\n    apiRef = _ref8.apiRef,\n    firstRowToRender = _ref8.firstRowToRender,\n    lastRowToRender = _ref8.lastRowToRender,\n    visibleRows = _ref8.visibleRows;\n  var firstNonSpannedColumnToRender = firstColumnToRender;\n  for (var i = firstRowToRender; i < lastRowToRender; i += 1) {\n    var row = visibleRows[i];\n    if (row) {\n      var rowId = visibleRows[i].id;\n      var cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender(_ref9) {\n  var firstColumnIndex = _ref9.firstColumnIndex,\n    minColumnIndex = _ref9.minColumnIndex,\n    columnBuffer = _ref9.columnBuffer,\n    firstRowToRender = _ref9.firstRowToRender,\n    lastRowToRender = _ref9.lastRowToRender,\n    apiRef = _ref9.apiRef,\n    visibleRows = _ref9.visibleRows;\n  var initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  var firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: apiRef,\n    firstRowToRender: firstRowToRender,\n    lastRowToRender: lastRowToRender,\n    visibleRows: visibleRows\n  });\n  return firstColumnToRender;\n}","map":{"version":3,"names":["_extends","DEFAULT_GRID_COL_TYPE_KEY","getGridDefaultColumnTypes","gridColumnsSelector","gridColumnVisibilityModelSelector","clamp","COLUMNS_DIMENSION_PROPERTIES","computeColumnTypes","customColumnTypes","arguments","length","undefined","mergedColumnTypes","Object","entries","forEach","_ref","_ref2","_slicedToArray","colType","colTypeDef","extendType","computeFlexColumnsWidth","_ref3","initialFreeSpace","totalFlexUnits","flexColumns","flexColumnsLookup","all","frozenFields","freeze","field","value","frozen","push","loopOverFlexItems","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","keys","_ref4","hydrateColumnsWidth","rawState","viewportInnerWidth","columnsLookup","widthAllocatedBeforeFlex","columnField","newColumn","lookup","columnVisibilityModel","width","Math","computedColumnWidths","columnTypeWarnedOnce","applyInitialState","columnsState","initialState","_initialState$ordered","orderedFields","_initialState$dimensi","dimensions","columnsWithUpdatedDimensions","orderedFieldsLookup","cleanOrderedFields","newOrderedFields","concat","_toConsumableArray","filter","newColumnLookup","_loop","newColDef","hasBeenResized","_ref5","_ref6","key","Infinity","newColumnsState","getGridColDef","columnTypes","type","process","env","NODE_ENV","console","warn","join","createColumnsState","_ref7","apiRef","columnsToUpsert","_ref7$currentColumnVi","currentColumnVisibilityModel","shouldRegenColumnVisibilityModelFromColumns","_ref7$keepOnlyColumns","keepOnlyColumnsToUpsert","_apiRef$current$getRo","_apiRef$current$getRo2","_apiRef$current","_apiRef$current$getRo3","isInsideStateInitializer","current","state","columns","columnsStateWithoutColumnVisibilityModel","currentState","columnsToKeep","reduce","acc","_defineProperty","columnsToUpsertLookup","existingState","hide","columnsLookupBeforePreProcessing","columnsStateWithPreProcessing","unstable_applyPipeProcessors","hasModelChanged","newColumnVisibilityModel","isVisibleBefore","isVisibleAfter","columnsStateWithPortableColumns","getRootDimensions","call","viewportInnerSize","mergeColumnsState","getFirstNonSpannedColumnToRender","_ref8","firstColumnToRender","firstRowToRender","lastRowToRender","visibleRows","firstNonSpannedColumnToRender","row","rowId","id","cellColSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","getFirstColumnIndexToRender","_ref9","firstColumnIndex","minColumnIndex","columnBuffer","initialFirstColumnToRender"],"sources":["/Users/guilherme/Downloads/react-loan-calculator-main/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../colDef';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nexport const computeColumnTypes = (customColumnTypes = {}) => {\n  const mergedColumnTypes = _extends({}, getGridDefaultColumnTypes());\n\n  Object.entries(customColumnTypes).forEach(([colType, colTypeDef]) => {\n    if (mergedColumnTypes[colType]) {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colType], colTypeDef);\n    } else {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    }\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nlet columnTypeWarnedOnce = false;\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.all : [...cleanOrderedFields, ...columnsState.all.filter(field => !orderedFieldsLookup[field])];\n\n  const newColumnLookup = _extends({}, columnsState.lookup);\n\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n\n  const newColumnsState = {\n    all: newOrderedFields,\n    lookup: newColumnLookup\n  };\n  return newColumnsState;\n};\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport const getGridColDef = (columnTypes, type) => {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([`MUI: The column type \"${type}\" you are using is not supported.`, `Column type \"string\" is being used instead.`].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  return columnTypes[type];\n};\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnTypes,\n  currentColumnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  shouldRegenColumnVisibilityModelFromColumns,\n  keepOnlyColumnsToUpsert = false\n}) => {\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsStateWithoutColumnVisibilityModel;\n\n  if (isInsideStateInitializer) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    const currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: keepOnlyColumnsToUpsert ? [] : [...currentState.all],\n      lookup: _extends({}, currentState.lookup) // Will be cleaned later if keepOnlyColumnsToUpsert=true\n\n    };\n  }\n\n  let columnsToKeep = {};\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsStateWithoutColumnVisibilityModel.lookup[field];\n\n    if (existingState == null) {\n      // New Column\n      existingState = _extends({}, getGridColDef(columnTypes, newColumn.type), {\n        // TODO v6: Inline `getGridColDef`\n        field,\n        hasBeenResized: false\n      });\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsStateWithoutColumnVisibilityModel.all.push(field);\n    }\n\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsStateWithoutColumnVisibilityModel.lookup[field] = _extends({}, existingState, {\n      hide: newColumn.hide == null ? false : newColumn.hide\n    }, newColumn, {\n      hasBeenResized\n    });\n  });\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsStateWithoutColumnVisibilityModel.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsStateWithoutColumnVisibilityModel.lookup[field];\n      }\n    });\n  }\n\n  const columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  let columnVisibilityModel = {};\n\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    let hasModelChanged = false;\n\n    const newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n\n    if (isInsideStateInitializer) {\n      columnsStateWithPreProcessing.all.forEach(field => {\n        newColumnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else if (keepOnlyColumnsToUpsert) {\n      // At this point, `keepOnlyColumnsToUpsert` has a new meaning: keep the columns\n      // passed via `columnToUpsert` + columns added by the pre-processors. We do the following\n      // cleanup because a given column may have been removed from the `columns` prop but it still\n      // exists in the state.\n      Object.keys(newColumnVisibilityModel).forEach(field => {\n        if (!columnsStateWithPreProcessing.lookup[field]) {\n          delete newColumnVisibilityModel[field];\n          hasModelChanged = true;\n        }\n      });\n    }\n\n    columnsStateWithPreProcessing.all.forEach(field => {\n      // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n      // Then we don't want to update the visibility status of the column in the model.\n      if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n        return;\n      } // We always assume that a column not in the model is visible by default. However, there's an\n      // edge case where the column is not in the model but it also doesn't exist in the `columns`\n      // prop, meaning that the column is being added. In that case, we assume that the column was\n      // not visible before for it be added to the model.\n\n\n      let isVisibleBefore = currentColumnVisibilityModel[field];\n\n      if (isVisibleBefore === undefined) {\n        if (isInsideStateInitializer) {\n          isVisibleBefore = true;\n        } else {\n          const currentState = gridColumnsSelector(apiRef.current.state);\n          isVisibleBefore = !!currentState.lookup[field];\n        }\n      }\n\n      const isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n\n      if (isVisibleAfter !== isVisibleBefore) {\n        hasModelChanged = true;\n        newColumnVisibilityModel[field] = isVisibleAfter;\n      }\n    });\n\n    if (hasModelChanged || isInsideStateInitializer) {\n      columnVisibilityModel = newColumnVisibilityModel;\n    } else {\n      columnVisibilityModel = currentColumnVisibilityModel;\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n\n  const columnsState = _extends({}, columnsStateWithPortableColumns, {\n    columnVisibilityModel\n  });\n\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});\nexport function getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender({\n  firstColumnIndex,\n  minColumnIndex,\n  columnBuffer,\n  firstRowToRender,\n  lastRowToRender,\n  apiRef,\n  visibleRows\n}) {\n  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  });\n  return firstColumnToRender;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}