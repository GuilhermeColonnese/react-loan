{"ast":null,"code":"import _slicedToArray from \"/Users/guilherme/Downloads/react-loan-calculator-main/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/Users/guilherme/Downloads/react-loan-calculator-main/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/guilherme/Downloads/react-loan-calculator-main/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector, gridRowsIdToIdLookupSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport var rowsStateInitializer = function rowsStateInitializer(state, props, apiRef) {\n  apiRef.current.unstable_caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef: apiRef,\n      previousTree: null,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading\n    })\n  });\n};\nexport var useGridRows = function useGridRows(apiRef, props) {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {// Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n  var logger = useGridLogger(apiRef, 'useGridRows');\n  var currentPage = useGridVisibleRows(apiRef, props);\n  var lastUpdateMs = React.useRef(Date.now());\n  var timeout = React.useRef(null);\n  var getRow = React.useCallback(function (id) {\n    var _ref;\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  var lookup = React.useMemo(function () {\n    return currentPage.rows.reduce(function (acc, _ref2, index) {\n      var id = _ref2.id;\n      acc[id] = index;\n      return acc;\n    }, {});\n  }, [currentPage.rows]);\n  var throttledRowsChange = React.useCallback(function (newCache, throttle) {\n    var run = function run() {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(function (state) {\n        return _extends({}, state, {\n          rows: getRowsStateFromCache({\n            apiRef: apiRef,\n            previousTree: gridRowTreeSelector(apiRef),\n            rowCountProp: props.rowCount,\n            loadingProp: props.loading\n          })\n        });\n      });\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n    apiRef.current.unstable_caches.rows = newCache;\n    if (!throttle) {\n      run();\n      return;\n    }\n    var throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  var setRows = React.useCallback(function (rows) {\n    logger.debug(\"Updating all rows, new length \".concat(rows.length));\n    var cache = createRowsInternalCache({\n      rows: rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    var prevCache = apiRef.current.unstable_caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange(cache, true);\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  var updateRows = React.useCallback(function (updates) {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n    var uniqueUpdates = new Map();\n    updates.forEach(function (update) {\n      var id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n      if (uniqueUpdates.has(id)) {\n        uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n      } else {\n        uniqueUpdates.set(id, update);\n      }\n    });\n    var deletedRowIds = [];\n    var prevCache = apiRef.current.unstable_caches.rows;\n    var newCache = {\n      rowsBeforePartialUpdates: prevCache.rowsBeforePartialUpdates,\n      loadingPropBeforePartialUpdates: prevCache.loadingPropBeforePartialUpdates,\n      rowCountPropBeforePartialUpdates: prevCache.rowCountPropBeforePartialUpdates,\n      idRowsLookup: _extends({}, prevCache.idRowsLookup),\n      idToIdLookup: _extends({}, prevCache.idToIdLookup),\n      ids: _toConsumableArray(prevCache.ids)\n    };\n    uniqueUpdates.forEach(function (partialRow, id) {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newCache.idRowsLookup[id];\n        delete newCache.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n      var oldRow = apiRef.current.getRow(id);\n      if (!oldRow) {\n        newCache.idRowsLookup[id] = partialRow;\n        newCache.idToIdLookup[id] = id;\n        newCache.ids.push(id);\n        return;\n      }\n      newCache.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n    if (deletedRowIds.length > 0) {\n      newCache.ids = newCache.ids.filter(function (id) {\n        return !deletedRowIds.includes(id);\n      });\n    }\n    throttledRowsChange(newCache, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  var getRowModels = React.useCallback(function () {\n    var allRows = gridRowIdsSelector(apiRef);\n    var idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(function (id) {\n      return [id, idRowsLookup[id]];\n    }));\n  }, [apiRef]);\n  var getRowsCount = React.useCallback(function () {\n    return gridRowCountSelector(apiRef);\n  }, [apiRef]);\n  var getAllRowIds = React.useCallback(function () {\n    return gridRowIdsSelector(apiRef);\n  }, [apiRef]);\n  var getRowIndexRelativeToVisibleRows = React.useCallback(function (id) {\n    return lookup[id];\n  }, [lookup]);\n  var setRowChildrenExpansion = React.useCallback(function (id, isExpanded) {\n    var currentNode = apiRef.current.getRowNode(id);\n    if (!currentNode) {\n      throw new Error(\"MUI: No row with id #\".concat(id, \" found\"));\n    }\n    var newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, _defineProperty({}, id, newNode))\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  var getRowNode = React.useCallback(function (id) {\n    var _gridRowTreeSelector$;\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  var getRowGroupChildren = React.useCallback(function (_ref3) {\n    var _ref3$skipAutoGenerat = _ref3.skipAutoGeneratedRows,\n      skipAutoGeneratedRows = _ref3$skipAutoGenerat === void 0 ? true : _ref3$skipAutoGenerat,\n      groupId = _ref3.groupId,\n      applySorting = _ref3.applySorting,\n      applyFiltering = _ref3.applyFiltering;\n    var tree = gridRowTreeSelector(apiRef);\n    var children;\n    if (applySorting) {\n      var groupNode = tree[groupId];\n      if (!groupNode) {\n        return [];\n      }\n      var sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      var startIndex = sortedRowIds.findIndex(function (id) {\n        return id === groupId;\n      }) + 1;\n      for (var index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        var id = sortedRowIds[index];\n        var node = tree[id];\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n    if (applyFiltering) {\n      var filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(function (childId) {\n        return filteredRowsLookup[childId] !== false;\n      });\n    }\n    return children;\n  }, [apiRef]);\n  var setRowIndex = React.useCallback(function (rowId, targetIndex) {\n    var allRows = gridRowIdsSelector(apiRef);\n    var oldIndex = allRows.findIndex(function (row) {\n      return row === rowId;\n    });\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n    logger.debug(\"Moving row \".concat(rowId, \" to index \").concat(targetIndex));\n    var updatedRows = _toConsumableArray(allRows);\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          ids: updatedRows\n        })\n      });\n    });\n    apiRef.current.unstable_caches.rows.ids = updatedRows;\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  var replaceRows = React.useCallback(function (firstRowToRender, newRows) {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    if (newRows.length === 0) {\n      return;\n    }\n    var allRows = gridRowIdsSelector(apiRef);\n    var updatedRows = _toConsumableArray(allRows);\n    var idRowsLookup = gridRowsLookupSelector(apiRef);\n    var idToIdLookup = gridRowsIdToIdLookupSelector(apiRef);\n    var tree = gridRowTreeSelector(apiRef);\n    var updatedIdRowsLookup = _extends({}, idRowsLookup);\n    var updatedIdToIdLookup = _extends({}, idToIdLookup);\n    var updatedTree = _extends({}, tree);\n    var newRowEntries = newRows.map(function (newRowModel) {\n      var rowId = getRowIdFromRowModel(newRowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      return {\n        id: rowId,\n        model: newRowModel\n      };\n    });\n    newRowEntries.forEach(function (row, index) {\n      var _updatedRows$splice = updatedRows.splice(firstRowToRender + index, 1, row.id),\n        _updatedRows$splice2 = _slicedToArray(_updatedRows$splice, 1),\n        replacedRowId = _updatedRows$splice2[0];\n      delete updatedIdRowsLookup[replacedRowId];\n      delete updatedIdToIdLookup[replacedRowId];\n      delete updatedTree[replacedRowId];\n    });\n    newRowEntries.forEach(function (row) {\n      var rowTreeNodeConfig = {\n        id: row.id,\n        parent: null,\n        depth: 0,\n        groupingKey: null,\n        groupingField: null\n      };\n      updatedIdRowsLookup[row.id] = row.model;\n      updatedIdToIdLookup[row.id] = row.id;\n      updatedTree[row.id] = rowTreeNodeConfig;\n    });\n    apiRef.current.unstable_caches.rows.idRowsLookup = updatedIdRowsLookup;\n    apiRef.current.unstable_caches.rows.idToIdLookup = updatedIdToIdLookup;\n    apiRef.current.unstable_caches.rows.ids = updatedRows;\n    apiRef.current.setState(function (state) {\n      var newRowsState = {\n        idRowsLookup: updatedIdRowsLookup,\n        idToIdLookup: updatedIdToIdLookup,\n        tree: updatedTree,\n        ids: updatedRows\n      };\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, newRowsState, {\n          groupingResponseBeforeRowHydration: _extends({}, state.rows.groupingResponseBeforeRowHydration, newRowsState)\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  var rowApi = {\n    getRow: getRow,\n    getRowModels: getRowModels,\n    getRowsCount: getRowsCount,\n    getAllRowIds: getAllRowIds,\n    setRows: setRows,\n    setRowIndex: setRowIndex,\n    updateRows: updateRows,\n    setRowChildrenExpansion: setRowChildrenExpansion,\n    getRowNode: getRowNode,\n    getRowIndexRelativeToVisibleRows: getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren: getRowGroupChildren,\n    unstable_replaceRows: replaceRows\n  };\n  /**\n   * EVENTS\n   */\n\n  var groupRows = React.useCallback(function () {\n    logger.info(\"Row grouping pre-processing have changed, regenerating the row tree\");\n    var cache;\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = apiRef.current.unstable_caches.rows;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n    throttledRowsChange(cache, false);\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  var handleStrategyProcessorChange = React.useCallback(function (methodName) {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  var handleStrategyActivityChange = React.useCallback(function () {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  var applyHydrateRowsProcessor = React.useCallback(function () {\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, apiRef.current.unstable_applyPipeProcessors('hydrateRows', state.rows.groupingResponseBeforeRowHydration))\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(function () {\n    return function () {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  var isFirstRender = React.useRef(true);\n  React.useEffect(function () {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    var areNewRowsAlreadyInState = apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows;\n    var isNewLoadingAlreadyInState = apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    var isNewRowCountAlreadyInState = apiRef.current.unstable_caches.rows.rowCountPropBeforePartialUpdates === props.rowCount; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(function (state) {\n          return _extends({}, state, {\n            rows: _extends({}, state.rows, {\n              loading: props.loading\n            })\n          });\n        });\n        apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(function (state) {\n          return _extends({}, state, {\n            rows: _extends({}, state.rows, {\n              totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n              totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n            })\n          });\n        });\n        apiRef.current.unstable_caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n      return;\n    }\n    logger.debug(\"Updating all rows, new length \".concat(props.rows.length));\n    throttledRowsChange(createRowsInternalCache({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowIdsSelector","gridRowGroupingNameSelector","gridRowsIdToIdLookupSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","getTreeNodeDescendants","createRowsInternalCache","getRowsStateFromCache","getRowIdFromRowModel","useGridRegisterPipeApplier","rowsStateInitializer","state","props","apiRef","current","unstable_caches","rows","getRowId","loading","rowCount","previousTree","rowCountProp","loadingProp","useGridRows","process","env","NODE_ENV","Object","freeze","error","logger","currentPage","lastUpdateMs","useRef","Date","now","timeout","getRow","useCallback","id","_ref","lookup","useMemo","reduce","acc","_ref2","index","throttledRowsChange","newCache","throttle","run","setState","publishEvent","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","concat","length","cache","prevCache","rowsBeforePartialUpdates","updateRows","updates","signature","DataGrid","Error","join","uniqueUpdates","Map","forEach","update","has","set","get","deletedRowIds","loadingPropBeforePartialUpdates","rowCountPropBeforePartialUpdates","idRowsLookup","idToIdLookup","ids","_toConsumableArray","partialRow","_action","push","oldRow","filter","includes","getRowModels","allRows","map","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","getRowNode","newNode","childrenExpanded","tree","_defineProperty","_gridRowTreeSelector$","getRowGroupChildren","_ref3","_ref3$skipAutoGenerat","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","node","isAutoGenerated","filteredRowsLookup","childId","setRowIndex","rowId","targetIndex","oldIndex","row","updatedRows","splice","replaceRows","firstRowToRender","newRows","updatedIdRowsLookup","updatedIdToIdLookup","updatedTree","newRowEntries","newRowModel","model","_updatedRows$splice","_updatedRows$splice2","_slicedToArray","replacedRowId","rowTreeNodeConfig","parent","groupingKey","groupingField","newRowsState","groupingResponseBeforeRowHydration","rowApi","unstable_replaceRows","groupRows","info","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","unstable_getActiveStrategy","applyHydrateRowsProcessor","unstable_applyPipeProcessors","useEffect","isFirstRender","areNewRowsAlreadyInState","isNewLoadingAlreadyInState","isNewRowCountAlreadyInState","totalRowCount","Math","max","totalTopLevelRowCount"],"sources":["/Users/guilherme/Downloads/react-loan-calculator-main/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector, gridRowsIdToIdLookupSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.unstable_caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      previousTree: null,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {// Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newCache, throttle) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          previousTree: gridRowTreeSelector(apiRef),\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.unstable_caches.rows = newCache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.unstable_caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange(cache, true);\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqueUpdates = new Map();\n    updates.forEach(update => {\n      const id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqueUpdates.has(id)) {\n        uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n      } else {\n        uniqueUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const prevCache = apiRef.current.unstable_caches.rows;\n    const newCache = {\n      rowsBeforePartialUpdates: prevCache.rowsBeforePartialUpdates,\n      loadingPropBeforePartialUpdates: prevCache.loadingPropBeforePartialUpdates,\n      rowCountPropBeforePartialUpdates: prevCache.rowCountPropBeforePartialUpdates,\n      idRowsLookup: _extends({}, prevCache.idRowsLookup),\n      idToIdLookup: _extends({}, prevCache.idToIdLookup),\n      ids: [...prevCache.ids]\n    };\n    uniqueUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newCache.idRowsLookup[id];\n        delete newCache.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newCache.idRowsLookup[id] = partialRow;\n        newCache.idToIdLookup[id] = id;\n        newCache.ids.push(id);\n        return;\n      }\n\n      newCache.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newCache.ids = newCache.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    throttledRowsChange(newCache, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        const node = tree[id];\n\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.unstable_caches.rows.ids = updatedRows;\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    if (newRows.length === 0) {\n      return;\n    }\n\n    const allRows = gridRowIdsSelector(apiRef);\n    const updatedRows = [...allRows];\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    const idToIdLookup = gridRowsIdToIdLookupSelector(apiRef);\n    const tree = gridRowTreeSelector(apiRef);\n\n    const updatedIdRowsLookup = _extends({}, idRowsLookup);\n\n    const updatedIdToIdLookup = _extends({}, idToIdLookup);\n\n    const updatedTree = _extends({}, tree);\n\n    const newRowEntries = newRows.map(newRowModel => {\n      const rowId = getRowIdFromRowModel(newRowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      return {\n        id: rowId,\n        model: newRowModel\n      };\n    });\n    newRowEntries.forEach((row, index) => {\n      const [replacedRowId] = updatedRows.splice(firstRowToRender + index, 1, row.id);\n      delete updatedIdRowsLookup[replacedRowId];\n      delete updatedIdToIdLookup[replacedRowId];\n      delete updatedTree[replacedRowId];\n    });\n    newRowEntries.forEach(row => {\n      const rowTreeNodeConfig = {\n        id: row.id,\n        parent: null,\n        depth: 0,\n        groupingKey: null,\n        groupingField: null\n      };\n      updatedIdRowsLookup[row.id] = row.model;\n      updatedIdToIdLookup[row.id] = row.id;\n      updatedTree[row.id] = rowTreeNodeConfig;\n    });\n    apiRef.current.unstable_caches.rows.idRowsLookup = updatedIdRowsLookup;\n    apiRef.current.unstable_caches.rows.idToIdLookup = updatedIdToIdLookup;\n    apiRef.current.unstable_caches.rows.ids = updatedRows;\n    apiRef.current.setState(state => {\n      const newRowsState = {\n        idRowsLookup: updatedIdRowsLookup,\n        idToIdLookup: updatedIdToIdLookup,\n        tree: updatedTree,\n        ids: updatedRows\n      };\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, newRowsState, {\n          groupingResponseBeforeRowHydration: _extends({}, state.rows.groupingResponseBeforeRowHydration, newRowsState)\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren,\n    unstable_replaceRows: replaceRows\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = apiRef.current.unstable_caches.rows;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n\n    throttledRowsChange(cache, false);\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, apiRef.current.unstable_applyPipeProcessors('hydrateRows', state.rows.groupingResponseBeforeRowHydration))\n    }));\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    const areNewRowsAlreadyInState = apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.unstable_caches.rows.rowCountPropBeforePartialUpdates === props.rowCount; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.unstable_caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}